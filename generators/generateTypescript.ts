#!/usr/bin/env bun
import { readFileSync } from "node:fs";
import { gen, Code } from "../cg-types/generators/gen";
import { parseRouterFns } from "../cg-types/generators/parseRouterFns";

// check if this file is being run directly based on args
if (process.argv[1]?.includes("generateTypescript.ts")) {
  setTimeout(() => {
    const arg = process.argv.slice(2)[0];
    const payload = arg ?? readFileSync(0, "utf8");
    const input = JSON.parse(payload) as gen.Input;
    const result = generateTypeScript(input);
    console.log(JSON.stringify(result));
  });
}

export function generateTypeScript(input: gen.Input): gen.Output {
  Code.docStringSettings.multi_line = {
    prefix: "/**",
    empty_line_pre: "\n *",
    line_pre: "\n * ",
    suffix: "\n */",
  };
  Code.docStringSettings.single_line = { prefix: "/** ", suffix: " */" };
  Code.docStringSettings.skip_rust_attrs = true;

  const errors: gen.OutputMessage[] = [];
  const fns = parseRouterFns(input, errors);
  
  // Generate router types file
  const routerOutput = generateRouterTypes(fns, "../");
  
  // Generate main types file
  const typesOutput = generateTypes(input, "../");

  return {
    errors,
    files: [
      { path: "router.gen.ts", source: routerOutput.toString() },
      { path: "index.ts", source: typesOutput.toString() },
    ],
    warnings: [],
  };
}

function generateRouterTypes(fns: ReturnType<typeof parseRouterFns>, sourcePrefix = "") {
  // Collect unique input and response types
  const inputTypes = new Set<string>();
  const responseTypes = new Set<string>();
  
  for (const fn of fns) {
    const inputType = createFormat(fn.inputFmt).src;
    const responseType = createFormat(fn.responseFmt).src;
    
    if (inputType !== "void") inputTypes.add(inputType);
    if (responseType !== "void") responseTypes.add(responseType);
  }

  const allTypes = new Set([...inputTypes, ...responseTypes]);
  
  const output = Code.group([
    `// Auto-generated by derive-codegen`,
    `// Do not edit manually`,
    ``,
    ...(allTypes.size > 0 
      ? [`import type { ${Array.from(allTypes).join(", ")} } from "./index";`, ``]
      : []
    ),
    `/**`,
    ` * Auto-generated router types from Rust #[codegen(fn = "...")] attributes.`,
    ` * `,
    ` * All names use snake_case to exactly match Rust definitions.`,
    ` * No transformation applied - what you define in Rust is what you get in TypeScript.`,
    ` * `,
    ` * Implementation: src/router/router.ts`,
    ` */`,
    ``,
    `/**`,
    ` * Generated call parameter types for router requests.`,
    ` * Keys use snake_case to match Rust wire protocol.`,
    ` */`,
    `export type CallGen = {`,
    Code.indented(fns.flatMap((fn) => [
      ...Code.docString(fn.decl, undefined, [sourcePrefix, fn.decl.id_location]),
      `${fn.key}: ${createFormat(fn.inputFmt).src};`,
    ])),
    `};`,
    ``,
    `/**`,
    ` * Generated response types for router calls.`,
    ` * Keys use snake_case to match Rust wire protocol.`,
    ` */`,
    `export type ResponseNextGen = {`,
    Code.indented(fns.flatMap((fn) => [
      ...Code.docString(fn.decl, undefined, [sourcePrefix, fn.decl.id_location]),
      `${fn.key}: ${createFormat(fn.responseFmt).src};`,
    ])),
    `};`,
    ``,
    `/** Observable interface for streaming responses */`,
    `export interface Observable<T> {`,
    Code.indented([
      `subscribe(observer: {`,
      Code.indented([
        `next?: (value: T) => void;`,
        `error?: (error: string) => void;`,
        `complete?: (notes: string) => void;`,
      ]),
      `}): void;`,
    ]),
    `}`,
    ``,
    `/** Enhanced observable with convenience methods */`,
    `export interface EnhancedObservable<T> extends Observable<T> {`,
    Code.indented([
      `first(options?: { signal?: AbortSignal }): Promise<T>;`,
      `all(options?: { signal?: AbortSignal }): Promise<T[]>;`,
      `each(`,
      Code.indented([
        `fn: (value: T) => void,`,
        `options?: { signal?: AbortSignal },`,
      ]),
      `): AbortController;`,
    ]),
    `}`,
    ``,
    `/**`,
    ` * Generated Router interface.`,
    ` * Method names exactly match Rust function names (snake_case).`,
    ` * `,
    ` * This interface is automatically updated when Rust functions change.`,
    ` */`,
    `export interface Router {`,
    Code.indented(fns.flatMap((fn) => {
      const returnType = createFormat(fn.responseFmt).src === "void" 
        ? "EnhancedObservable<void>"
        : `EnhancedObservable<${createFormat(fn.responseFmt).src}>`;
      
      return [
        ...Code.docString(fn.decl, undefined, [sourcePrefix, fn.decl.id_location]),
        `${fn.key}(params: ${createFormat(fn.inputFmt).src}): ${returnType};`,
      ];
    })),
    Code.indented([`dispose(): void;`]),
    `}`,
  ]);

  return output;
}

function generateTypes(input: gen.Input, sourcePrefix = "") {
  const output = Code.group([
    `// Auto-generated by derive-codegen`,
    `// Do not edit manually`,
    ``,
    ...input.declarations.flatMap((decl) => {
      const typeCode = Code.group();
      
      // Add doc string if available
      typeCode.lines.push(...Code.docString(decl, undefined, [sourcePrefix, decl.id_location]));
      
      // Generate the type based on container kind
      const result = gen.ContainerFormat.match(decl.container_kind, {
        Struct: (structData) => {
          const { fields } = structData;
          if (fields.length === 0) {
            typeCode.add`export type ${decl.id} = Record<string, never>;`;
          } else {
            typeCode.add`export interface ${decl.id} {`;
            const fieldsCode = typeCode.indented();
            for (const field of fields) {
              fieldsCode.lines.push(...Code.docString(field, undefined, [sourcePrefix, field.id_location]));
              fieldsCode.add`${field.id}: ${createFormat(field.format).src};`;
            }
            typeCode.add`}`;
          }
        },
        NewTypeStruct: (inner) => {
          typeCode.add`export type ${decl.id} = ${createFormat(inner).src};`;
        },
        UnitStruct: () => {
          typeCode.add`export type ${decl.id} = Record<string, never>;`;
        },
        TupleStruct: (fields) => {
          const types = fields.map((f) => createFormat(f).src).join(", ");
          typeCode.add`export type ${decl.id} = [${types}];`;
        },
        Enum: (enumData) => {
          const { variants } = enumData;
          typeCode.add`export type ${decl.id} =`;
          const variantsCode = typeCode.indented();
          for (let i = 0; i < variants.length; i++) {
            const variant = variants[i];
            variantsCode.lines.push(...Code.docString(variant, undefined, [sourcePrefix, variant.id_location]));
            
            const result = gen.VariantFormat.match(variant.variant_format, {
              Unit: () => {
                const line = `| { type: "${variant.id}" }`;
                variantsCode.add`${line}${i < variants.length - 1 ? "" : ";"}`;
              },
              NewType: (inner) => {
                const line = `| { type: "${variant.id}"; value: ${createFormat(inner).src} }`;
                variantsCode.add`${line}${i < variants.length - 1 ? "" : ";"}`;
              },
              Tuple: (fields) => {
                const types = fields.map((f) => createFormat(f).src).join(", ");
                const line = `| { type: "${variant.id}"; value: [${types}] }`;
                variantsCode.add`${line}${i < variants.length - 1 ? "" : ";"}`;
              },
              Struct: (structData) => {
                const { fields } = structData;
                if (fields.length === 0) {
                  const line = `| { type: "${variant.id}" }`;
                  variantsCode.add`${line}${i < variants.length - 1 ? "" : ";"}`;
                } else {
                  variantsCode.add`| { type: "${variant.id}";`;
                  const structFields = variantsCode.indented();
                  for (const field of fields) {
                    structFields.lines.push(...Code.docString(field, undefined, [sourcePrefix, field.id_location]));
                    structFields.add`${field.id}: ${createFormat(field.format).src};`;
                  }
                  variantsCode.add`}${i < variants.length - 1 ? "" : ";"}`;
                }
              },
            });
          }
        },
      });
      
      return [...typeCode.lines, ``];
    }),
  ]);

  return output;
}

const simple = (src: string) => () => ({ src });

const createFormat: (format: gen.Format) => {
  src: string;
} = gen.Format.apply({
  TypeName: (value) => {
    const generics = value.generics.length ? `<${value.generics.map((g) => createFormat(g).src).join(", ")}>` : "";
    return { src: `${ident(value.ident)}${generics}` };
  },
  I8: simple("number"),
  I16: simple("number"),
  I32: simple("number"),
  I64: simple("number"),
  I128: simple("number"),
  ISIZE: simple("number"),
  U8: simple("number"),
  U16: simple("number"),
  U32: simple("number"),
  U64: simple("number"),
  U128: simple("number"),
  USIZE: simple("number"),
  F32: simple("number"),
  F64: simple("number"),
  Bool: simple("boolean"),
  Bytes: simple("Uint8Array"),
  Never: simple("never"),
  Char: simple("string"),
  Map: ({ key, value }) => ({
    src: `Map<${createFormat(key).src}, ${createFormat(value).src}>`,
  }),
  Unit: simple("void"),
  Option: (format) => ({ src: `${createFormat(format).src} | null` }),
  Incomplete: ({ debug }) => ({ src: `unknown /* Incomplete: ${debug} */` }),
  Seq: (seq) => ({ src: `${createFormat(seq).src}[]` }),
  Tuple: (tuple) => ({
    src: `[${tuple.map((tup) => createFormat(tup).src).join(", ")}]`,
  }),
  TupleArray: ({ content, size }) => ({
    src: `[${Array(size).fill(createFormat(content).src).join(", ")}]`,
  }),
  Str: simple("string"),
});

function ident(id: string): string {
  return id.replace(/[^a-zA-Z0-9$_]/g, "$").replace(/^(\d)/, "$$1");
}
