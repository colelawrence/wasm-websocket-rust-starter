import { readFileSync } from "node:fs";
import { gen, Code } from "./gen";
import { parseRouterFns } from "./parseRouterFns";

// check if this file is being run directly based on args
if (process.argv[1]?.includes("generateRustRouter.ts")) {
  setTimeout(() => {
    const arg = process.argv.slice(2)[0];
    const payload = arg ?? readFileSync(0, "utf8");
    const input = JSON.parse(payload) as gen.Input;
    // console.error("Input:", input);
    const result = generateRust(input, {
      fileName: "router_gen.rs",
    });
    // eslint-disable-next-line no-console
    console.log(JSON.stringify(result));
  });
}

export function generateRust(
  input: gen.Input,
  args: {
    /** What to call the file with all the declarations */
    fileName: string;
  },
): gen.Output {
  Code.docStringSettings.multi_line = {
    prefix: "",
    empty_line_pre: "///",
    line_pre: "\n/// ",
    suffix: "",
  };
  Code.docStringSettings.single_line = { prefix: "/// ", suffix: "" };
  Code.docStringSettings.skip_rust_attrs = true;

  const errors: gen.OutputMessage[] = [];
  const fns = parseRouterFns(input, errors);
  const seenFmts = new Set<string>();
  const output = Code.group([
    `//! This file is generated by \`cg-types\` crate.`,
    `//! Do not modify it directly.`,
    `#![cfg_attr(rustfmt, rustfmt_skip)]`,
    ``,
    `use std::hash::Hash;`,
    ``,
    `use serde::{Deserialize, Serialize};`,
    ``,
    `use super::{ObserverImpl, ResponseRouter, ToResponseNextGen};`,
    ``,
    `pub trait CallHandler {`,
    Code.indented([
      ...fns.flatMap((fn) => [
        `fn ${fn.key}(`,
        Code.indented([`&self,`, `params: ${createFormat(fn.inputFmt).src},`, `tx: ObserverImpl<${createFormat(fn.responseFmt).src}>,`]),
        `);`,
      ]),
    ]),
    `}`,
    ``,
    `/// Request (call) item`,
    `#[allow(non_camel_case_types)]`,
    `#[derive(Serialize, Deserialize, Debug, Clone)]`,
    `pub(crate) enum CallGen {`,
    Code.indented(fns.flatMap((fn) => [...Code.docString(fn.decl), `${fn.key}(${createFormat(fn.inputFmt).src}),`])),
    `}`,
    "",
    `/// Response item`,
    `#[allow(non_camel_case_types, clippy::large_enum_variant)]`,
    `#[derive(Serialize, Deserialize, Debug, Clone)]`,
    `#[doc(hidden)]`,
    `pub enum ResponseNextGen {`,
    Code.indented(fns.flatMap((fn) => [...Code.docString(fn.decl), `${fn.key}(${createFormat(fn.responseFmt).src}),`])),
    `}`,
    "",
    "pub(crate) fn gen_call<RCtx: Clone + Hash + PartialEq + Eq + Send + Sync + 'static>(",
    Code.indented(["router: &ResponseRouter<RCtx>,", "id: usize,", "call: CallGen,", "reply_context: RCtx,", "handler: &dyn CallHandler,"]),
    ") {",
    Code.indented([
      "let responder = router.create_responder(id, reply_context);",
      "match call {",
      Code.indented(
        fns.flatMap((fn) => [
          `CallGen::${fn.key}(params) => handler.${fn.key}(`,
          Code.indented([`params,`, `router.create_observer::<${createFormat(fn.responseFmt).src}>(responder),`]),
          `),`,
        ]),
      ),
      "}",
    ]),
    "}",
    "",
    "// impls",
    ...fns
      .filter((a) => {
        const fmt = createFormat(a.responseFmt).src;
        if (seenFmts.has(fmt)) {
          return false;
        }
        seenFmts.add(fmt);
        return true;
      })
      .flatMap((fn) => [
        `impl ToResponseNextGen for ${createFormat(fn.responseFmt).src} {`,
        Code.indented([`fn to_response_next_gen(self) -> ResponseNextGen {`, Code.indented([`ResponseNextGen::${fn.key}(self)`]), `}`]),
        `}`,
      ]),
    "",
  ]);

  return {
    errors,
    files: [{ path: args.fileName, source: output.toStringIndented("    ", 0) }],
    warnings: [],
  };
}

const simple = (src: string) => () => ({ src });

const createFormat: (format: gen.Format) => {
  src: string;
} = gen.Format.apply({
  TypeName: (value) => {
    const generics = value.generics.length ? `<${value.generics.map((g) => createFormat(g).src).join(", ")}>` : "";
    return { src: `crate::types::${ident(value.ident)}${generics}` };
  },
  I8: simple("i8"),
  I16: simple("i16"),
  I32: simple("i32"),
  I64: simple("i64"),
  I128: simple("i128"),
  ISIZE: simple("isize"),
  U8: simple("u8"),
  U16: simple("u16"),
  U32: simple("u32"),
  U64: simple("u64"),
  U128: simple("u128"),
  USIZE: simple("usize"),
  F32: simple("f32"),
  F64: simple("f64"),
  Bool: simple("bool"),
  Bytes: simple("Vec<u8>"),
  Never: simple("!"),
  Char: simple("char"),
  Map: ({ key, value }) => ({
    src: `std::collections::HashMap<${createFormat(key).src}, ${createFormat(value).src}>`,
  }),
  Unit: simple("()"),
  Option: (format) => ({ src: `Option<${createFormat(format).src}>` }),
  Incomplete: ({ debug }) => ({ src: `/* Incomplete: ${debug} */ unknown` }),
  Seq: (seq) => ({ src: `Array<${createFormat(seq).src}>` }),
  Tuple: (tuple) => ({
    src: `(${tuple.map((tup) => createFormat(tup).src).join(", ")})`,
  }),
  TupleArray: ({ content, size }) => ({
    src: `[${createFormat(content).src}; ${size}]`,
  }),
  Str: simple("String"),
});

function ident(id: string): string {
  return id.replace(/[^a-zA-Z0-9$_]/g, "$").replace(/^(\d)/, "$$1");
}
